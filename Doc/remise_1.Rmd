---
title: "Projet - Première remise"
output: 
  html_document:
    css: style.css
---

```{r, include = FALSE}

# Paramètres globaux -----------------------------------------------------------


knitr::opts_chunk$set(echo = FALSE)


# Fonctions utiles -------------------------------------------------------------


source("../R/utils.R")


# Librairies -------------------------------------------------------------------


libs <- c("knitr",
          "kableExtra",
          "naniar",
          "terra", "sf",
          "leaflet")

# Installer les librairies au besoin et les télécharger
inst_load_packages(libs)


# Chemin d'accès ---------------------------------------------------------------


data_path <- "../Data/s1_donnees_filtrees.rds"
shape_file_path <- "../Data/RiverATLAS_Data_v10_shp/RiverATLAS_v10_shp"


# Charger les données ----------------------------------------------------------


river_dt <- setDT(readRDS(data_path))


```

# 1. Présentation des données

## 1.1 Description

## 1.2 Collecte de données

Expliquer les biais possibles !


# 2. Premières analyses

## 2.1 Données manquantes

### Documentation de la non-réponse

#### Pourcentage de données manquantes par variable

Les données manquantes dans un jeu de données sont chose commune et peuvent être issues de diverses causes comme des capteurs défectueux, d'oublis lors de la collecte des données ou, encore, de mesures ajoutées en cours de route d'un projet. Notre jeu de données ne fait pas exception : nous avons des données manquantes dénotées par des _-999_'s. Pour faire le portrait des données manquantes de notre jeu de données, voici le Tableau 2.1.1 exposant les variables pour lesquelles nous avons des données manquantes et le nombre/pourcentage d'observations qui sont touchées :

```{r}

# Calcul du pourcentage par variable -------------------------------------------

# Calculer le nombre de données manquantes par variable et conserver que celles avec des données manquantes
var_missing_data <- unlist(lapply(
      X = river_dt, 
      FUN = function(x) {
         res <- sum(x == -999)
         if(res != 0) {res} else {NULL}
      }
   ))

# Changer les noms des variables 
names(var_missing_data) <- translate_var(names(var_missing_data))

# Changer le format de la table et le mettre en data.table
var_missing_data <- as.data.table(t(t(var_missing_data)), keep.rownames = TRUE)

# Calculer le % de données manquantes
var_missing_data[, pourc := paste0(round(V1 / nrow(river_dt) * 100, 1), "%")]

kbl(
   x = as.data.table(t(t(var_missing_data)), keep.rownames = TRUE), 
   align = c("l", "c", "c"), 
   col.names = c("Variables", "Nombre de données manquantes", "Pourcentage de données manquantes"), 
   caption = "Tableau 2.1.1 - Pourcentage de données manquantes par variable"
) %>% kable_classic(
   full_width = TRUE, 
   html_font = "Cambria"
)

```

L’acronyme *cav* désigne le bassin versant observé (*Catchment*), tandis que *uav* désigne une aggrégation des bassins en amont (*upstream*).
Nous remarquons qu'une variable ressort du lot avec un pourcentage de près de 44% de valeurs manquantes soit celle de la classification des zones humides. Or, dans la description des variables de notre jeu de données, [_RiverATLAS Attributes_](https://data.hydrosheds.org/file/technical-documentation/RiverATLAS_Catalog_v10.pdf), on y spécifie que les _-999_'s sont, en fait, les endroits n'ayant pas de zone humide ce qui explique pourquoi elles ne sont pas classifiées. Cette variable contient 12 classes numérotées de 1 à 12. Pour traiter les non-réponses de cette variable, nous y ajoutons un 13e classe qui équivaut à _aucune zone humide_. Nous remplaçons, donc, les valeurs _-999_ par un facteur correspondant à _0_.

```{r}


# Modifier les -999 par une classe pour la variable wet_cl_cmj

mod_missing_wet_cl_cmj(river_dt)


```

Pour ce qui est des autres variables présentées dans le tableau 2.1.1, celles-ci sont bien des valeurs manquantes qui nécessitent d'être analysées et traitées.

D'une part, notons que chaque variable est mesurée pour le bassin observé ( _cav_ ) et pour les bassins en amont ( _uav_ ). Or, dans ces cas, le patron de non-réponse est très similaire. En effet, si une variable est manquante pour tous les bassins en amont, elle le sera assurément pour le bassin présent. Par ailleurs, il est intéressant d'observer que la corrélation entre les variables _cav_ et _uav_ sont linéairement très corrélées.


```{r, echo = FALSE}

# Nous remplaçons les -999 par des NA
col_w_na <- get_col_w_na(river_dt, na_pattern = -999)
river_dt[, (col_w_na) := 
            lapply(
               X = .SD, 
               FUN = function(x) fifelse(x == -999, get_na_by_type(x), x)),
         .SDcols = col_w_na]

# Calculer les corrélation entre les mêmes variables, mais cav et uav
var_suffix <- 
   unique(
      sapply(
         grep("uav", col_w_na, value = TRUE), 
         function(x) substr(x, 1, nchar(x) - 4)
      )
   )

res <-
   sapply(var_suffix, function(nm)
      round(cor(
         river_dt[[paste0(nm, "_cav")]],
         river_dt[[paste0(nm, "_uav")]],
         use = "complete.obs"),
         2
      ))

kbl(
   x = t(as.data.table(res)), 
   align = rep("c", length(res)),  
   col.names = translate_var(names(res)), 
   caption = "Tableau 2.1.2 - Coefficient de corrélation entre les variables étiquetées cav et uav, pour différentes métriques"
) %>% kable_classic(
   full_width = TRUE, 
   html_font = "Cambria"
)

# Nous retirons les variables de notre jeu de données


river_dt <- river_dt[, !grep("cav", col_w_na, value = TRUE), with = FALSE]

```
Étant donné cette forte corrélation linéaire, et considérant qu'il y a nettement moins de valeurs manquantes pour les variables portant le suffixe  _uav_ que _cav_, nous retirons ces dernières.


#### Pourcentage par patron de non-réponse

Nous voyons dans le Tableau 2.1.3 le seul patron de non-réponse de notre jeu de données ainsi que la proportion des observations qui y est associé. Celui-ci est composé des variables de la composition du sol et il représente 0.06% de nos données. À noter que chacune de ces quatres variables proviennent d'une même source de données: [SoilGrids1km; Hengl et al. 2014](https://www.isric.org/explore/soilgrids).

```{r}

# Patrons de non-réponse -------------------------------------------------------

# Sélection des variables avec des valeurs manquantes
n <- get_col_w_na(river_dt)

# Création de la matrice R
R_dt <- as.data.table(is.na(river_dt[, n, with = FALSE]))

# Traduire les variables en leur description
names(R_dt) <- translate_var(names(R_dt))
n <- translate_var(n)

# Changer les -999 pour le nom de la variable manquante
R_dt[, (n) := lapply(n, function(var_name) {fifelse(R_dt[[var_name]], paste0("\U2022 ", var_name, " <br> "), "")})]

# Créer une colonne contenant l'ensemble des variables (patron) pour une observation
# donnée (une ligne) contenant des valeurs manquantes
R_dt[, pattern := apply(.SD, 1, function(x) paste(x, collapse = "")), .SDcols = n]

# Calculer le % de cas ayant chaque patron de valeurs manquantes
R_dt <- R_dt[pattern != "", paste0(round(.N / nrow(R_dt) * 100, 2), "%"), by = pattern]

R_dt <- cbind(data.table(num = 1:nrow(R_dt)), 
              R_dt)

R_dt %>%  knitr::kable(
   escape = FALSE,
   format = "html", 
   align = c("c", "l", "c"),
   col.names = c("Numéro", 
                 "Patrons de non-réponse", 
                 "Pourcentage de données manquantes"),
   caption = "Tableau 2.1.3 - Pourcentage de données manquantes par patron de non-réponse"
) %>% kable_classic(
   full_width = TRUE, 
   html_font = "Cambria"
) %>% row_spec(
   row = 1, 
   extra_css = "border-bottom: 1px solid")

```

Dans la documentation du jeu de données, il est précisé que les valeurs manquantes pour ces variables sont causées par la présence de grandes surfaces d'eau telles que des lacs. Pour s'en convaincre, la carte interactive suivante présente la localisation des bassins versants où on observe des valeurs manquantes.

```{r}
river_vec <- terra::vect(
   shape_file_path,
   extent = ext(c(-79.85, -55.53, 45.04, 62.80))
)
river_vec <- sf::st_as_sf(river_vec)
leaflet(river_vec[river_vec$slt_pc_uav == -999, ]) %>%
   addTiles() %>%
   addPolylines()

```


### Identifier le mécanisme de non-réponse

#### Distribution des autres variables

Nous faisons une analyse préliminaire pour évaluer si les données sont manquantes de façon complètement aléatoire. Pour ce faire, nous commençons à comparer les graphique de la distribution de variables explicatives pour les observations qui ne font pas parties du patron (`patron = 0`) au graphique de la même variable mais avec les observation qui font partie de ce patron (`patron = 1`). Nous montrons quelques exemples de variables dont la distribution changent en fonction de si les observations font parties du patron ou non ce qui suggère que nous ne sommes pas en présence de valeurs manquantes complètement aléatoire. 

```{r}
river_dt[, patron := 0]
river_dt[is.na(snd_pc_uav), patron := 1]
```

::: columns 

:::: column

```{r}
graph_density(river_dt, var = "dis_m3_pyr", color = "patron")
```

On voit que la distribution du débit d'eau moyen pour les observations manquantes ont beaucoup plus de poids dans les extrêmes et possède une moyenne largement plus grande.

::::

:::: column

```{r}
graph_density(river_dt, var = "lka_pc_use", color = "patron")
```
On voit que pour les observations manquantes semblent se retrouver dans des territoires avec un plus haut pourcentage de terre correspondant à des lacs supposant.

::::

:::

::: columns

:::: column

```{r}
graph_density(river_dt, var = "for_pc_use", color = "patron")
```
Les moyennes du pourcentage occupé par les forêts sont relativement similaires. Un _test-t_ nous permettrait de valider si elles sont significativement différente. Par contre, la distribution est différente avec les données sans données manquantes qui se retrouvent plus souvent dans les proportions élevées.


::::

:::: column

```{r}
graph_density(river_dt, var = "ero_kh_cav", color = "patron")
```

L'érosion des sols semble être moins élevée pour les données manquantes.

::::

:::

Cette analyse préliminaire des distributions suggère que nous ne sommes pas en présence de données manquantes de façon complètement aléatoire puisque visuellement les distributions de variables pour les données observées et les données manquantes sont différentes.

Pour poursuivre notre analyse, nous exposons dans le tableau suivant l'ensemble des _test-t_'s possibles pour comparer la moyenne des autres variables pour les observations faisant parties du patron et celle pour les observations ne faisant pas parties du patron

```{r}

# Calculer les test-t's
t_test_res <- t_test_by_patron(river_dt, "patron")

# Afficher sous forme de tableau les seuils observés des tests de comparaison 
# de moyenne
t_test_res[order(p_value, decreasing = TRUE)] %>%  knitr::kable(
   align = c("l", "c"),
   col.names = c("Variable", 
                 "Seuil observé"),
   caption = "Tableau 2.1.4 - Seuil observé pour les tests t entre les valeurs dans le patron et celles pas dans ce patron"
) %>% kable_classic(
   full_width = TRUE, 
   html_font = "Cambria"
) 

```

Nous remarquons que `r sum(t_test_res$p_value < 0.05)` tests ont un seuil observé en dessous de 5%. Cela signifie que pour ces tests la moyenne de la variable évaluée est significativement différente en présence ou non du patron de non-réponse.

En revanche, faire autant de _test-t_'s a ses limites. En effet, puisque nous faisons au total `r nrow(t_test_res)`, nous avons le problème de comparaisons multiples qui implique que, même si toutes les moyennes étaient réellement égales, une partie des tests seraient rejetée. Or, dans notre cas, une très grande partie le sont ce qui appuie notre hypothèse comme quoi les données ne sont pas manquantes complètement aléatoirement.


#### Test de Little

Pour valider nos analyses préliminaires, nous utilisons le test de _Little_, qui calcule une statistique telle que :


$$d^2 = \sum_{j = 1}^J (\hat{\mu}_j - \hat{\mu}_j^{ML})\hat\Sigma_j^{-1}(\hat{\mu}_j - \hat{\mu}_j^{ML})$$
Si les données sont manquantes de façon complètement aléatoire, nous aurons que $$d^2 \sim \chi_{\sum_{j=1}^J k_j-k}.$$ 

```{r, warning = FALSE}

river_dt[, c("patron", "var_color")] <- list(NULL)
nm <- names(river_dt) 
res <- mcar_test(river_dt[, nm[toupper(nm) != nm], with = FALSE])

```

En utilisant la formule `naniar::mcar_test`, nous obtenons que le seuil observé est de `r res$p.value` qui confirme notre hypothèse. On rejette, donc, l'hypothèse $H_0 :$ Données manquantes avec un mécanisme _MCAR_.


#### Conclusion de l'analyse
En conclusion, comme la non-réponse pouvait être prédite selon la variable de
pourcentage de couverture des lacs dans le bassin (`lka_pc_cse`) et que
ce patron était associé à des valeurs significativement différentes pour les
autres variables, on peut affirmer que le patron de non-réponse est MAR.

Évidemment, le fait de retirer des données MAR peut introduire un biais.
Néanmoins, l'objectif de ce travail est de prédire le débit d'eau des rivières. Comme il n'y a pas de sens à calculer un débit d'eau dans un lac, nous allons simplement retirer ces observations du jeu de données.


## 2.2 Réduction de la dimensionalité


